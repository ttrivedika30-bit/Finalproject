"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.State = exports.IteratorPager = void 0;
class IteratorPager {
    pageIterableIterator;
    state = State.NEW;
    constructor(pageIterableIterator) {
        this.pageIterableIterator = pageIterableIterator;
    }
    hasNext() {
        return this.pageIterableIterator.hasNext();
    }
    async getNext() {
        this.checkState(State.GET_NEXT);
        const nextElement = await this.pageIterableIterator.next();
        if (!this.hasNext()) {
            this.state = State.CONSUMED;
        }
        if (nextElement.done) {
            throw new Error('No more results available.');
        }
        return nextElement.value;
    }
    async getAll() {
        this.checkState(State.GET_ALL);
        const items = [];
        // eslint-disable-next-line no-restricted-syntax
        for await (const page of this.pageIterableIterator) {
            items.push(...page);
        }
        // If it didn't throw we can set the consumed state
        this.state = State.CONSUMED;
        const readOnlyItems = [...items];
        return readOnlyItems;
    }
    checkState(state) {
        if (this.state === state) {
            return;
        }
        switch (this.state) {
            case State.NEW:
                this.state = state;
                break;
            case State.CONSUMED:
                throw new Error('This pager has been consumed, use a new Pager.');
            default:
                throw new Error('Cannot mix getAll() and getNext(), use only one method or get a a new Pager.');
        }
    }
}
exports.IteratorPager = IteratorPager;
var State;
(function (State) {
    State[State["NEW"] = 0] = "NEW";
    State[State["GET_NEXT"] = 1] = "GET_NEXT";
    State[State["GET_ALL"] = 2] = "GET_ALL";
    State[State["CONSUMED"] = 3] = "CONSUMED";
})(State || (exports.State = State = {}));
//# sourceMappingURL=iteratorPager.js.map